import { __read } from "tslib";
// (C) 2022 GoodData Corporation
import React from "react";
import cx from "classnames";
import invariant from "ts-invariant";
import { getDropZoneDebugStyle } from "../debug";
import { selectSettings, useDashboardDispatch, useDashboardSelector, addSectionItem, removeSectionItem, selectWidgetPlaceholderCoordinates, } from "../../../model";
import { useDashboardDrop } from "../useDashboardDrop";
import { isInsightDraggableListItem, isInsightPlaceholderDraggableItem, isKpiPlaceholderDraggableItem, } from "../types";
import { getInsightPlaceholderSizeInfo, getSizeInfo } from "../../../_staging/layout/sizing";
import { useKpiPlaceholderDropHandler } from "./useKpiPlaceholderDropHandler";
import { useInsightListItemDropHandler } from "./useInsightListItemDropHandler";
import { useInsightPlaceholderDropHandler } from "./useInsightPlaceholderDropHandler";
import { newPlaceholderWidget } from "../../../widgets";
function getDraggableItemSizeInfo(settings, item) {
    if (isInsightDraggableListItem(item)) {
        return getSizeInfo(settings, "insight", item.insight);
    }
    if (isKpiPlaceholderDraggableItem(item)) {
        return getSizeInfo(settings, "kpi");
    }
    if (isInsightPlaceholderDraggableItem(item)) {
        return getInsightPlaceholderSizeInfo(settings);
    }
    invariant(false, "unsupported draggable item");
}
export var Hotspot = function (props) {
    var itemIndex = props.itemIndex, sectionIndex = props.sectionIndex, classNames = props.classNames, dropZoneType = props.dropZoneType;
    var dispatch = useDashboardDispatch();
    var settings = useDashboardSelector(selectSettings);
    var widgetPlaceholderCoords = useDashboardSelector(selectWidgetPlaceholderCoordinates);
    // for "next" we need to add the item after the current index, for "prev" on the current one
    var targetItemIndex = dropZoneType === "next" ? itemIndex + 1 : itemIndex;
    var handleInsightListItemDrop = useInsightListItemDropHandler();
    var handleInsightPlaceholderDrop = useInsightPlaceholderDropHandler();
    var handleKpiPlaceholderDrop = useKpiPlaceholderDropHandler();
    var needsToAddWidgetDropzone = !widgetPlaceholderCoords || // first placeholder ever
        widgetPlaceholderCoords.sectionIndex !== sectionIndex || // or different section
        (dropZoneType === "prev" && widgetPlaceholderCoords.itemIndex !== itemIndex - 1) || // or not immediately before for prev hotspot
        (dropZoneType === "next" && widgetPlaceholderCoords.itemIndex !== itemIndex + 1); // or not immediately after for next hotspot
    var _a = __read(useDashboardDrop(["insightListItem", "kpi-placeholder", "insight-placeholder"], {
        drop: function (item) {
            if (isInsightDraggableListItem(item)) {
                handleInsightListItemDrop(item.insight);
            }
            if (isKpiPlaceholderDraggableItem(item)) {
                handleKpiPlaceholderDrop();
            }
            if (isInsightPlaceholderDraggableItem(item)) {
                handleInsightPlaceholderDrop();
            }
        },
        hover: function (item) {
            if (!needsToAddWidgetDropzone) {
                return;
            }
            // we will definitely be adding a new placeholder, so remove the current one if any
            if (widgetPlaceholderCoords) {
                dispatch(removeSectionItem(widgetPlaceholderCoords.sectionIndex, widgetPlaceholderCoords.itemIndex));
            }
            var sizeInfo = getDraggableItemSizeInfo(settings, item);
            dispatch(addSectionItem(sectionIndex, targetItemIndex, {
                type: "IDashboardLayoutItem",
                size: {
                    xl: {
                        gridHeight: sizeInfo.height.default,
                        gridWidth: sizeInfo.width.default,
                    },
                },
                widget: newPlaceholderWidget(),
            }));
        },
    }, [
        dispatch,
        widgetPlaceholderCoords,
        settings,
        targetItemIndex,
        sectionIndex,
        handleInsightListItemDrop,
        handleInsightPlaceholderDrop,
        handleKpiPlaceholderDrop,
    ]), 2), _b = _a[0], canDrop = _b.canDrop, isOver = _b.isOver, dropRef = _a[1];
    var debugStyle = getDropZoneDebugStyle({ isOver: isOver });
    return (React.createElement("div", { className: cx(classNames, "dropzone", dropZoneType, { hidden: !canDrop }), style: debugStyle, ref: dropRef }));
};
//# sourceMappingURL=Hotspot.js.map