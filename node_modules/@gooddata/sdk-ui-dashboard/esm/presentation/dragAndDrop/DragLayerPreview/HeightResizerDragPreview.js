import { __read, __spread } from "tslib";
// (C) 2021-2022 GoodData Corporation
import React, { useEffect, useState } from "react";
import { HeightResizer } from "../Resize/HeightResizer";
import { fluidLayoutDescriptor } from "@gooddata/sdk-ui-ext";
import { useResizeHandlers } from "../LayoutResizeContext";
import { getLimitedSize } from "./sizeLimiting";
export var HeightResizerDragPreview = function (props) {
    var item = props.item, initialOffset = props.initialOffset, differenceFromInitialOffset = props.differenceFromInitialOffset, scrollCorrection = props.scrollCorrection, getDragLayerPosition = props.getDragLayerPosition;
    var toggleHeightLimitReached = useResizeHandlers().toggleHeightLimitReached;
    var _a = __read(useState("none"), 2), hasReachedLimit = _a[0], setReachedLimit = _a[1];
    useEffect(function () {
        toggleHeightLimitReached(hasReachedLimit);
    }, [hasReachedLimit, toggleHeightLimitReached]);
    var dragLayerOffset = getDragLayerPosition();
    var currentUnlimitedHeightGR = getNewHeightGR(item.widgetHeights, differenceFromInitialOffset.y, scrollCorrection.y);
    useEffect(function () {
        var hasNowReachedLimit = hasHeightReachedLimit(currentUnlimitedHeightGR, item.minLimit, item.maxLimit);
        if (hasNowReachedLimit !== hasReachedLimit) {
            setReachedLimit(hasNowReachedLimit);
        }
    }, [currentUnlimitedHeightGR, item.minLimit, item.maxLimit, hasReachedLimit]);
    var top = getLimitedYCoord(item, initialOffset.y, differenceFromInitialOffset.y, scrollCorrection.y);
    var style = {
        top: top + 4 - dragLayerOffset.y + scrollCorrection.y + "px",
        left: initialOffset.x - dragLayerOffset.x + scrollCorrection.x + "px",
        right: "30px",
    };
    return (React.createElement("div", { className: "height-resizer-drag-preview s-height-resizer-drag-preview", style: style },
        React.createElement(HeightResizer, { status: "active" })));
};
function getPrimaryHeightGR(heightsGR) {
    heightsGR = heightsGR || [10];
    return Math.max.apply(Math, __spread(heightsGR));
}
function hasHeightReachedLimit(heightGR, min, max) {
    if (heightGR < min)
        return "min";
    if (heightGR > max)
        return "max";
    return "none";
}
function getNewHeightGR(widgetHeights, offsetYPX, scrollingCorrectionY) {
    var primaryHeightGR = getPrimaryHeightGR(widgetHeights);
    var totalDelta = offsetYPX - scrollingCorrectionY;
    var deltaHeightGR = fluidLayoutDescriptor.toGridHeight(totalDelta);
    return primaryHeightGR + deltaHeightGR;
}
export function getLimitedYCoord(item, initialSourceClientOffsetY, differenceFromInitialOffsetY, scrollingCorrectionY) {
    var minLimit = item.minLimit, maxLimit = item.maxLimit;
    var deltaSize = fluidLayoutDescriptor.toGridHeight(differenceFromInitialOffsetY - scrollingCorrectionY);
    var curPrimaryHeightGR = getPrimaryHeightGR(item.widgetHeights);
    var newSizeLimited = getLimitedSize(minLimit, maxLimit, curPrimaryHeightGR, deltaSize);
    var deltaY = fluidLayoutDescriptor.toHeightInPx(newSizeLimited - curPrimaryHeightGR);
    return initialSourceClientOffsetY + deltaY;
}
//# sourceMappingURL=HeightResizerDragPreview.js.map