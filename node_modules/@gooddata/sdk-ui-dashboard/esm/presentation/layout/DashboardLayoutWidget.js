// (C) 2020-2022 GoodData Corporation
import React, { useRef } from "react";
import { isWidget, widgetType as getWidgetType, isKpiWidget, isInsightWidget, } from "@gooddata/sdk-model";
import { selectEnableWidgetCustomHeight, selectInsightsMap, selectIsInEditMode, selectSettings, useDashboardSelector, } from "../../model";
import { DashboardWidget } from "../widget";
import { getDashboardLayoutItemHeight, getDashboardLayoutItemHeightForRatioAndScreen, } from "./DefaultDashboardLayoutRenderer";
import { useDashboardComponentsContext } from "../dashboardContexts";
import { Hotspot, WidthResizerHotspot, ResizeOverlay, useResizeItemStatus } from "../dragAndDrop";
import { getDashboardLayoutWidgetDefaultHeight } from "../../_staging/layout/sizing";
import { isAnyPlaceholderWidget } from "../../widgets";
import { DEFAULT_COLUMN_CLIENT_WIDTH, DEFAULT_WIDTH_RESIZER_HEIGHT } from "./constants";
function calculateWidgetMinHeight(widget, currentSize, insights, settings) {
    var widgetType;
    var insight;
    var content;
    if (isWidget(widget)) {
        widgetType = getWidgetType(widget);
    }
    if (isInsightWidget(widget)) {
        insight = insights.get(widget.insight);
        content = insight;
    }
    if (isKpiWidget(widget)) {
        content = widget.kpi;
    }
    return (getDashboardLayoutItemHeight(currentSize) ||
        (!currentSize.heightAsRatio
            ? getDashboardLayoutWidgetDefaultHeight(settings, widgetType, content)
            : undefined));
}
/**
 * Tests in KD require widget index for css selectors.
 * Widget index equals to the widget order in the layout.
 * Also placeholders are ignored for this.
 */
function getWidgetIndex(item) {
    var _a, _b;
    var sectionIndex = item.section().index();
    var isIgnoredForIndexes = function (widget) {
        return !widget || isAnyPlaceholderWidget(widget);
    };
    var itemsInSectionsBefore = 0;
    for (var i = 0; i < sectionIndex; i += 1) {
        itemsInSectionsBefore += (_b = (_a = item
            .section()
            .layout()
            .section(i)) === null || _a === void 0 ? void 0 : _a.items().filter(function (i) { return !isIgnoredForIndexes(i.widget()); }).length) !== null && _b !== void 0 ? _b : 0;
    }
    var ignoredWidgetsBeforeItemCount = item
        .section()
        .items()
        .filter(function (i) { return i.index() < item.index() && isIgnoredForIndexes(i.widget()); }).length;
    return itemsInSectionsBefore + item.index() - ignoredWidgetsBeforeItemCount;
}
/**
 * @internal
 */
export var DashboardLayoutWidget = function (props) {
    var item = props.item, screen = props.screen, DefaultWidgetRenderer = props.DefaultWidgetRenderer, onDrill = props.onDrill, onFiltersChange = props.onFiltersChange, onError = props.onError, getLayoutDimensions = props.getLayoutDimensions;
    var insights = useDashboardSelector(selectInsightsMap);
    var settings = useDashboardSelector(selectSettings);
    var isInEditMode = useDashboardSelector(selectIsInEditMode);
    var enableWidgetCustomHeight = useDashboardSelector(selectEnableWidgetCustomHeight);
    var _a = useDashboardComponentsContext(), ErrorComponent = _a.ErrorComponent, LoadingComponent = _a.LoadingComponent;
    // TODO: we should probably do something more meaningful when item has no widget; should that even
    //  be allowed? undefined widget will make things explode down the line away so..
    var widget = item.widget();
    var currentSize = item.size()[screen];
    var minHeight = calculateWidgetMinHeight(widget, currentSize, insights, settings);
    var height = currentSize.heightAsRatio && !currentSize.gridHeight
        ? getDashboardLayoutItemHeightForRatioAndScreen(currentSize, screen)
        : undefined;
    var allowOverflow = !!currentSize.heightAsRatio;
    var className = enableWidgetCustomHeight ? "custom-height" : undefined;
    var index = getWidgetIndex(item);
    var _b = useResizeItemStatus(widget.identifier), isActive = _b.isActive, isResizingColumnOrRow = _b.isResizingColumnOrRow, heightLimitReached = _b.heightLimitReached, widthLimitReached = _b.widthLimitReached;
    var contentRef = useRef(null);
    function getWidthInPx() {
        return (contentRef === null || contentRef === void 0 ? void 0 : contentRef.current) ? contentRef.current.getBoundingClientRect().width
            : DEFAULT_COLUMN_CLIENT_WIDTH;
    }
    function getHeightInPx() {
        return (contentRef === null || contentRef === void 0 ? void 0 : contentRef.current) ? contentRef.current.getBoundingClientRect().height
            : DEFAULT_WIDTH_RESIZER_HEIGHT;
    }
    function getGridColumnWidth() {
        var _a;
        var columnWidthInGC = (_a = item.sizeForScreen(screen)) === null || _a === void 0 ? void 0 : _a.gridWidth;
        var columnWidthInPx = getWidthInPx();
        return columnWidthInPx / columnWidthInGC;
    }
    return (React.createElement(DefaultWidgetRenderer, { DefaultWidgetRenderer: DefaultWidgetRenderer, item: item, screen: screen, allowOverflow: allowOverflow, height: height, minHeight: minHeight, className: className, contentRef: contentRef, getLayoutDimensions: getLayoutDimensions },
        React.createElement(DashboardWidget
        // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
        , { 
            // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
            index: index, screen: screen, onDrill: onDrill, onError: onError, onFiltersChange: onFiltersChange, widget: widget, ErrorComponent: ErrorComponent, LoadingComponent: LoadingComponent }),
        isInEditMode && !isAnyPlaceholderWidget(widget) && (React.createElement(React.Fragment, null,
            React.createElement(ResizeOverlay, { isActive: isActive, isResizingColumnOrRow: isResizingColumnOrRow, reachedWidthLimit: widthLimitReached, reachedHeightLimit: heightLimitReached }),
            React.createElement(Hotspot, { dropZoneType: "prev", itemIndex: item.index(), sectionIndex: item.section().index(), isLastInSection: false }),
            React.createElement(Hotspot, { dropZoneType: "next", itemIndex: item.index(), sectionIndex: item.section().index(), isLastInSection: item.isLast() }),
            React.createElement(WidthResizerHotspot, { item: item, screen: screen, getGridColumnHeightInPx: getHeightInPx, getGridColumnWidth: getGridColumnWidth, getLayoutDimensions: getLayoutDimensions })))));
};
//# sourceMappingURL=DashboardLayoutWidget.js.map