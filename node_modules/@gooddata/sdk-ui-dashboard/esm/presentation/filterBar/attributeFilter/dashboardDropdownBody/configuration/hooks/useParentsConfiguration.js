import { __assign, __read, __spread } from "tslib";
import { useState, useMemo, useCallback } from "react";
import invariant from "ts-invariant";
import isEqual from "lodash/isEqual";
import { setAttributeFilterParents, useDispatchDashboardCommand, } from "../../../../../../model";
import { useOriginalConfigurationState } from "./useOriginalConfigurationState";
export function useParentsConfiguration(neighborFilters, currentFilter) {
    var _a = currentFilter.attributeFilter, filterElementsBy = _a.filterElementsBy, currentFilterLocalId = _a.localIdentifier;
    invariant(currentFilterLocalId, "Cannot initialize the attribute filter configuration panel, filter has missing 'localIdentifier' property");
    var saveParentFilterCommand = useDispatchDashboardCommand(setAttributeFilterParents);
    var originalState = useOriginalConfigurationState(neighborFilters, filterElementsBy);
    var _b = __read(useState(originalState), 2), parents = _b[0], setParents = _b[1];
    function onParentSelect(localIdentifier, isSelected, overAttributes) {
        var changedParentIndex = parents.findIndex(function (parent) { return parent.localIdentifier === localIdentifier; });
        var changedItem = __assign({}, parents[changedParentIndex]);
        changedItem.isSelected = isSelected;
        changedItem.overAttributes = overAttributes;
        if (isSelected) {
            changedItem.selectedConnectingAttribute = overAttributes[0];
        }
        else {
            // set connecting attributes to undefined to properly check for
            // state updates
            changedItem.selectedConnectingAttribute = undefined;
            changedItem.overAttributes = undefined;
        }
        var changedParentItems = __spread(parents);
        changedParentItems[changedParentIndex] = changedItem;
        setParents(changedParentItems);
    }
    function onConnectingAttributeChanged(localIdentifier, selectedAttribute) {
        var changedParentIndex = parents.findIndex(function (parent) { return parent.localIdentifier === localIdentifier; });
        var changedItem = __assign({}, parents[changedParentIndex]);
        changedItem.selectedConnectingAttribute = selectedAttribute;
        var changedParentItems = __spread(parents);
        changedParentItems[changedParentIndex] = changedItem;
        setParents(changedParentItems);
    }
    var configurationChanged = useMemo(function () {
        return !isEqual(parents, originalState);
    }, [parents, originalState]);
    var onParentFiltersChange = useCallback(function () {
        // dispatch the command only if the configuration changed
        if (configurationChanged) {
            var parentFilters_1 = [];
            parents.forEach(function (parentItem) {
                var _a;
                if (parentItem.isSelected && ((_a = parentItem.overAttributes) === null || _a === void 0 ? void 0 : _a.length)) {
                    var overAttribute = parentItem.selectedConnectingAttribute || parentItem.overAttributes[0];
                    parentFilters_1.push({
                        filterLocalIdentifier: parentItem.localIdentifier,
                        over: {
                            attributes: [overAttribute],
                        },
                    });
                }
            });
            saveParentFilterCommand(currentFilter.attributeFilter.localIdentifier, parentFilters_1);
        }
    }, [parents, configurationChanged, currentFilter, saveParentFilterCommand]);
    var onConfigurationClose = useCallback(function () {
        setParents(originalState);
    }, [originalState]);
    return {
        parents: parents,
        configurationChanged: configurationChanged,
        onParentSelect: onParentSelect,
        onConnectingAttributeChanged: onConnectingAttributeChanged,
        onParentFiltersChange: onParentFiltersChange,
        onConfigurationClose: onConfigurationClose,
    };
}
//# sourceMappingURL=useParentsConfiguration.js.map