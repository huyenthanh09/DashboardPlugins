// (C) 2020-2022 GoodData Corporation
import React, { useMemo } from "react";
import { UnexpectedError } from "@gooddata/sdk-backend-spi";
import { isWidget, isInsightWidget, isDashboardWidget, widgetRef } from "@gooddata/sdk-model";
import { BackendProvider, convertError, useBackendStrict } from "@gooddata/sdk-ui";
import { withEventing } from "@gooddata/sdk-backend-base";
import { useDashboardEventDispatch } from "../../../model";
import { widgetExecutionFailed, widgetExecutionStarted, widgetExecutionSucceeded, } from "../../../model/events/widget";
import { safeSerializeObjRef } from "../../../_staging/metadata/safeSerializeObjRef";
import { DefaultDashboardKpiWidget } from "./DefaultDashboardKpiWidget";
import { RenderModeAwareDashboardInsightWidget } from "./InsightWidget";
/**
 * @internal
 */
export var DefaultDashboardWidget = function (props) {
    var onError = props.onError, onFiltersChange = props.onFiltersChange, screen = props.screen, widget = props.widget, backend = props.backend, 
    // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
    index = props.index;
    if (!isDashboardWidget(widget)) {
        throw new UnexpectedError("Cannot render custom widget with DefaultWidgetRenderer! Please handle custom widget rendering in your widgetRenderer.");
    }
    var ref = widgetRef(widget);
    var dispatchEvent = useDashboardEventDispatch();
    var effectiveBackend = useBackendStrict(backend);
    var backendWithEventing = useMemo(function () {
        // use a flag to report only the first result of the execution as per the events documented API
        var hasReportedResult = false;
        var onSuccess = function (dataView, executionId) {
            if (!hasReportedResult) {
                dispatchEvent(widgetExecutionSucceeded(ref, dataView, executionId));
                hasReportedResult = true;
            }
        };
        var onError = function (error, executionId) {
            if (!hasReportedResult) {
                dispatchEvent(widgetExecutionFailed(ref, convertError(error), executionId));
                hasReportedResult = true;
            }
        };
        return withEventing(effectiveBackend, {
            beforeExecute: function (def, executionId) {
                hasReportedResult = false;
                dispatchEvent(widgetExecutionStarted(ref, def, executionId));
            },
            successfulResultReadAll: onSuccess,
            successfulResultReadWindow: function (_offset, _limit, dataView, executionId) {
                onSuccess(dataView, executionId);
            },
            failedExecute: onError,
            failedResultReadAll: onError,
            failedResultReadWindow: function (_offset, _limit, error, executionId) {
                onError(error, executionId);
            },
        });
    }, [effectiveBackend, dispatchEvent, safeSerializeObjRef(ref)]);
    var dashboardItemClasses = "s-dash-item-" + index;
    if (isWidget(widget)) {
        return (React.createElement(BackendProvider, { backend: backendWithEventing }, isInsightWidget(widget) ? (React.createElement(RenderModeAwareDashboardInsightWidget, { widget: widget, screen: screen, dashboardItemClasses: dashboardItemClasses })) : (React.createElement(DefaultDashboardKpiWidget, { kpiWidget: widget, screen: screen, dashboardItemClasses: dashboardItemClasses, onFiltersChange: onFiltersChange, onError: onError }))));
    }
    return React.createElement("div", null, "Unknown widget");
};
//# sourceMappingURL=DefaultDashboardWidget.js.map