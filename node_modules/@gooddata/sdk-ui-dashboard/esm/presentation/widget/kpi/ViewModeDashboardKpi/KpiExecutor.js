import { __assign } from "tslib";
// (C) 2020-2022 GoodData Corporation
import React, { memo, useCallback, useEffect, useMemo } from "react";
import { useIntl } from "react-intl";
import { objRefToString, widgetRef, } from "@gooddata/sdk-model";
import { convertDrillableItemsToPredicates, isSomeHeaderPredicateMatched, NoDataSdkError, } from "@gooddata/sdk-ui";
import { filterContextItemsToDashboardFiltersByWidget } from "../../../../converters";
import { selectDrillableItems, selectCanCreateScheduledMail, selectSettings, selectCurrentUser, useDashboardAsyncRender, useDashboardSelector, useDashboardUserInteraction, useWidgetExecutionsHandler, selectValidConfiguredDrillsByWidgetRef, uiActions, useDashboardDispatch, selectIsKpiAlertOpenedByWidgetRef, selectIsKpiAlertHighlightedByWidgetRef, selectEnableWidgetCustomHeight, selectDateFormat, useWidgetSelection, } from "../../../../model";
import { DashboardItemHeadline } from "../../../presentationComponents";
import { KpiAlertDialogWrapper } from "./KpiAlertDialogWrapper";
import { useKpiAlertOperations } from "./useKpiAlertOperations";
import { DashboardItemWithKpiAlert, evaluateAlertTriggered } from "./KpiAlerts";
import { useWidgetBrokenAlertsQuery } from "../../common/useWidgetBrokenAlertsQuery";
import { invariant } from "ts-invariant";
import { dashboardFilterToFilterContextItem, getAlertThresholdInfo, getKpiAlertResult, getKpiResult, KpiRenderer, stripDateDatasets, useKpiExecutionDataView, } from "../common";
var KpiExecutorCore = function (props) {
    var dashboardRef = props.dashboardRef, kpiWidget = props.kpiWidget, backend = props.backend, workspace = props.workspace, primaryMeasure = props.primaryMeasure, secondaryMeasure = props.secondaryMeasure, effectiveFilters = props.effectiveFilters, alert = props.alert, separators = props.separators, disableDrillUnderline = props.disableDrillUnderline, isReadOnly = props.isReadOnly, onDrill = props.onDrill, onError = props.onError, onFiltersChange = props.onFiltersChange;
    var intl = useIntl();
    var kpiWidgetRef = widgetRef(kpiWidget);
    var _a = useKpiExecutionDataView({
        backend: backend,
        workspace: workspace,
        primaryMeasure: primaryMeasure,
        secondaryMeasure: secondaryMeasure,
        effectiveFilters: effectiveFilters,
        shouldLoad: true,
    }), error = _a.error, result = _a.result, status = _a.status;
    var isLoading = status === "loading" || status === "pending";
    var _b = useKpiExecutionDataView({
        backend: backend,
        workspace: workspace,
        primaryMeasure: primaryMeasure,
        effectiveFilters: effectiveFilters,
        shouldLoad: true,
    }), alertExecutionError = _b.error, alertExecutionResult = _b.result, alertExecutionStatus = _b.status;
    var isAlertExecutionLoading = alertExecutionStatus === "loading" || alertExecutionStatus === "pending";
    var currentUser = useDashboardSelector(selectCurrentUser);
    var canCreateScheduledMail = useDashboardSelector(selectCanCreateScheduledMail);
    var settings = useDashboardSelector(selectSettings);
    var enableCompactSize = useDashboardSelector(selectEnableWidgetCustomHeight);
    var dateFormat = useDashboardSelector(selectDateFormat);
    var drillableItems = useDashboardSelector(selectDrillableItems);
    var widgetDrills = useDashboardSelector(selectValidConfiguredDrillsByWidgetRef(kpiWidgetRef));
    var isAlertDialogOpen = useDashboardSelector(selectIsKpiAlertOpenedByWidgetRef(kpiWidgetRef));
    var isAlertHighlighted = useDashboardSelector(selectIsKpiAlertHighlightedByWidgetRef(kpiWidgetRef));
    var dispatch = useDashboardDispatch();
    var openAlertDialog = useCallback(function () {
        dispatch(uiActions.openKpiAlertDialog(kpiWidgetRef));
    }, [kpiWidgetRef, dispatch]);
    var closeAlertDialog = useCallback(function () {
        dispatch(uiActions.closeKpiAlertDialog());
    }, [dispatch]);
    var brokenAlertsBasicInfo = useWidgetBrokenAlertsQuery(kpiWidget, alert).result;
    var isAlertBroken = !!(brokenAlertsBasicInfo === null || brokenAlertsBasicInfo === void 0 ? void 0 : brokenAlertsBasicInfo.length);
    var executionsHandler = useWidgetExecutionsHandler(widgetRef(kpiWidget));
    useEffect(function () {
        var err = error !== null && error !== void 0 ? error : alertExecutionError;
        if (err) {
            onError === null || onError === void 0 ? void 0 : onError(err);
        }
        // for executions we care only about KPI errors
        if (error) {
            executionsHandler.onError(error);
        }
    }, [error, alertExecutionError]);
    useEffect(function () {
        if (result) {
            // empty data is considered an error for execution handling
            if (result.rawData().isEmpty()) {
                executionsHandler.onError(new NoDataSdkError());
            }
            else {
                executionsHandler.onSuccess(result.result());
            }
        }
    }, [result]);
    var handleOnDrill = useCallback(function (drillContext) {
        if (!onDrill) {
            return false;
        }
        return onDrill({
            dataView: result === null || result === void 0 ? void 0 : result.dataView,
            drillContext: drillContext,
            drillDefinitions: kpiWidget.drills,
            widgetRef: widgetRef(kpiWidget),
        });
    }, [onDrill, result, kpiWidget]);
    var kpiAlertOperations = useKpiAlertOperations(closeAlertDialog);
    var canSetAlert = canCreateScheduledMail;
    var _c = useDashboardAsyncRender(objRefToString(widgetRef(kpiWidget))), onRequestAsyncRender = _c.onRequestAsyncRender, onResolveAsyncRender = _c.onResolveAsyncRender;
    useEffect(function () {
        if (isLoading) {
            onRequestAsyncRender();
        }
        else {
            onResolveAsyncRender();
        }
        executionsHandler.onLoadingChanged({ isLoading: !!isLoading });
    }, [isLoading, onRequestAsyncRender, onResolveAsyncRender]);
    var _d = useDashboardUserInteraction(), kpiAlertDialogClosed = _d.kpiAlertDialogClosed, kpiAlertDialogOpened = _d.kpiAlertDialogOpened;
    var kpiResult = getKpiResult(result, primaryMeasure, secondaryMeasure, separators);
    var kpiAlertResult = getKpiAlertResult(alertExecutionResult, primaryMeasure, separators);
    var _e = useMemo(function () { return getAlertThresholdInfo(kpiResult, intl); }, [kpiResult, intl]), isThresholdRepresentingPercent = _e.isThresholdRepresentingPercent, thresholdPlaceholder = _e.thresholdPlaceholder;
    var predicates = convertDrillableItemsToPredicates(drillableItems);
    var isDrillable = ((kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureDescriptor) &&
        result &&
        isSomeHeaderPredicateMatched(predicates, kpiResult.measureDescriptor, result)) ||
        widgetDrills.length > 0;
    var alertSavingStatus = kpiAlertOperations.creatingStatus === "inProgress" ||
        kpiAlertOperations.updatingStatus === "inProgress"
        ? "inProgress"
        : kpiAlertOperations.creatingStatus === "error" || kpiAlertOperations.updatingStatus === "error"
            ? "error"
            : "idle";
    var _f = useWidgetSelection(kpiWidgetRef), isSelectable = _f.isSelectable, isSelected = _f.isSelected, onSelected = _f.onSelected;
    return (React.createElement(DashboardItemWithKpiAlert, { kpi: kpiWidget, alert: alert, filters: effectiveFilters, userWorkspaceSettings: settings, kpiResult: kpiResult, renderHeadline: function (clientHeight) { return (React.createElement(DashboardItemHeadline, { title: kpiWidget.title, clientHeight: clientHeight })); }, kpiAlertResult: kpiAlertResult, canSetAlert: canSetAlert, isReadOnlyMode: isReadOnly, alertExecutionError: alertExecutionError !== null && alertExecutionError !== void 0 ? alertExecutionError : 
        /*
         * if alert is broken, behave as if its execution yielded no data (which is true, we do not execute it)
         * context: the problem is alerts on KPIs without dateDataset, their date filters are invalid
         * and we have no idea what date dataset to put there hence it is sometimes impossible
         * to execute them (unlike KPI Dashboards, we do not have the guarantee that there is a date
         * filter in the filters)
         */
        (isAlertBroken ? new NoDataSdkError() : undefined), isLoading: isLoading, isAlertLoading: false /* alerts are always loaded at this point */, isAlertExecutionLoading: isAlertExecutionLoading, isAlertBroken: isAlertBroken, isAlertDialogOpen: isAlertDialogOpen, isAlertHighlighted: isAlertHighlighted, onAlertDialogOpenClick: function () {
            kpiAlertDialogOpened(!!alert);
            openAlertDialog();
        }, renderAlertDialog: function () { return (React.createElement(KpiAlertDialogWrapper, { alert: alert, dateFormat: dateFormat, userEmail: currentUser.email, onAlertDialogCloseClick: function () {
                kpiAlertDialogClosed();
                closeAlertDialog();
            }, onAlertDialogDeleteClick: function () {
                kpiAlertOperations.onRemoveAlert(alert);
            }, onAlertDialogSaveClick: function (threshold, whenTriggered) {
                var _a, _b;
                if (alert) {
                    return kpiAlertOperations.onUpdateAlert(__assign(__assign({}, alert), { threshold: threshold,
                        whenTriggered: whenTriggered, isTriggered: evaluateAlertTriggered(kpiAlertResult.measureResult, threshold, whenTriggered) }));
                }
                // alerts are not possible when the dashboard is not yet persisted. if the code bombs here
                // then it means we use view-mode KPI widget in edit-mode dashboard - there is a configuration
                // customization error somewhere.
                invariant(dashboardRef, "attempting to create alert of an unsaved dashboard");
                return kpiAlertOperations.onCreateAlert({
                    dashboard: dashboardRef,
                    widget: kpiWidgetRef,
                    threshold: threshold,
                    whenTriggered: whenTriggered,
                    isTriggered: evaluateAlertTriggered((_a = kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) !== null && _a !== void 0 ? _a : 0, threshold, whenTriggered),
                    filterContext: {
                        title: "filterContext",
                        description: "",
                        filters: (_b = effectiveFilters === null || effectiveFilters === void 0 ? void 0 : effectiveFilters.map(dashboardFilterToFilterContextItem).map(stripDateDatasets)) !== null && _b !== void 0 ? _b : [],
                    },
                    description: "",
                    title: "",
                });
            }, onAlertDialogUpdateClick: function () {
                var _a, _b;
                return kpiAlertOperations.onUpdateAlert(__assign(__assign({}, alert), { 
                    // evaluate triggered as if the alert already used the correct filters (i.e. use the KPI execution itself)
                    isTriggered: evaluateAlertTriggered((_a = kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) !== null && _a !== void 0 ? _a : 0, alert.threshold, alert.whenTriggered), 
                    // change the filters to the filters currently used by the KPI
                    filterContext: __assign(__assign({}, alert.filterContext), { filters: (_b = effectiveFilters === null || effectiveFilters === void 0 ? void 0 : effectiveFilters.map(dashboardFilterToFilterContextItem).map(stripDateDatasets)) !== null && _b !== void 0 ? _b : [] }) }));
            }, onApplyAlertFiltersClick: onFiltersChange
                ? function () {
                    var _a, _b;
                    return onFiltersChange(filterContextItemsToDashboardFiltersByWidget((_b = (_a = alert === null || alert === void 0 ? void 0 : alert.filterContext) === null || _a === void 0 ? void 0 : _a.filters) !== null && _b !== void 0 ? _b : [], kpiWidget), true);
                }
                : undefined, isAlertLoading: isAlertExecutionLoading, alertDeletingStatus: kpiAlertOperations.removingStatus, alertSavingStatus: alertSavingStatus, alertUpdatingStatus: alertSavingStatus, filters: effectiveFilters, isThresholdRepresentingPercent: isThresholdRepresentingPercent, thresholdPlaceholder: thresholdPlaceholder, brokenAlertFiltersBasicInfo: brokenAlertsBasicInfo, backend: backend, workspace: workspace })); }, alertDeletingStatus: kpiAlertOperations.removingStatus, alertSavingStatus: alertSavingStatus, isSelectable: isSelectable, isSelected: isSelected, onSelected: onSelected }, function () {
        return (React.createElement(KpiRenderer, { kpi: kpiWidget, kpiResult: kpiResult, filters: effectiveFilters !== null && effectiveFilters !== void 0 ? effectiveFilters : [], disableDrillUnderline: disableDrillUnderline, isDrillable: isDrillable, onDrill: onDrill && handleOnDrill, separators: separators, enableCompactSize: enableCompactSize, error: error, errorHelp: intl.formatMessage({ id: "kpi.error.view" }), isLoading: isLoading }));
    }));
};
/**
 * Executes the given measures and displays them as KPI
 * @internal
 */
export var KpiExecutor = memo(KpiExecutorCore);
//# sourceMappingURL=KpiExecutor.js.map