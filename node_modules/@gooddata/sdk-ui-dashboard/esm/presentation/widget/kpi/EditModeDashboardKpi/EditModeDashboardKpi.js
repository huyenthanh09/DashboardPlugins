// (C) 2022 GoodData Corporation
import React, { useCallback, useEffect, useMemo } from "react";
import cx from "classnames";
import { useIntl } from "react-intl";
import noop from "lodash/noop";
import { widgetRef } from "@gooddata/sdk-model";
import { useBackendStrict, useWorkspaceStrict } from "@gooddata/sdk-ui";
import { useDashboardSelector, useWidgetExecutionsHandler, selectEnableWidgetCustomHeight, selectSeparators, selectDisableKpiDashboardHeadlineUnderline, useDashboardDispatch, selectWidgetCoordinatesByRef, selectFilterContextFilters, uiActions, useWidgetSelection, selectIsDashboardSaving, changeKpiWidgetHeader, selectAllCatalogMeasuresMap, } from "../../../../model";
import { DashboardItemKpi } from "../../../presentationComponents";
import { useDashboardComponentsContext } from "../../../dashboardContexts";
import { ConfigurationBubble } from "../../common";
import { getKpiResult, KpiRenderer, useKpiData, useKpiExecutionDataView } from "../common";
import { useOptimisticMeasureUpdate } from "./useOptimisticMeasureUpdate";
import { EditableKpiHeadline } from "./EditModeKpiHeadline";
export var EditModeDashboardKpi = function (props) {
    var kpiWidget = props.kpiWidget, customBackend = props.backend, customWorkspace = props.workspace, CustomErrorComponent = props.ErrorComponent, CustomLoadingComponent = props.LoadingComponent, onError = props.onError;
    var intl = useIntl();
    var _a = useDashboardComponentsContext({
        ErrorComponent: CustomErrorComponent,
        LoadingComponent: CustomLoadingComponent,
    }), ErrorComponent = _a.ErrorComponent, LoadingComponent = _a.LoadingComponent, KpiWidgetComponentSet = _a.KpiWidgetComponentSet;
    var KpiConfigurationComponent = KpiWidgetComponentSet.configuration.WidgetConfigPanelComponent;
    var _b = useOptimisticMeasureUpdate(kpiWidget), isChangingMeasure = _b.isChangingMeasure, titleToShow = _b.titleToShow;
    var backend = useBackendStrict(customBackend);
    var workspace = useWorkspaceStrict(customWorkspace);
    var dashboardFilters = useDashboardSelector(selectFilterContextFilters);
    var _c = useKpiData({ kpiWidget: kpiWidget, dashboardFilters: dashboardFilters }), kpiDataError = _c.error, kpiDataResult = _c.result, kpiDataStatus = _c.status;
    var _d = kpiDataResult !== null && kpiDataResult !== void 0 ? kpiDataResult : {}, primaryMeasure = _d.primaryMeasure, secondaryMeasure = _d.secondaryMeasure, effectiveFilters = _d.effectiveFilters;
    var enableCompactSize = useDashboardSelector(selectEnableWidgetCustomHeight);
    var separators = useDashboardSelector(selectSeparators);
    var disableDrillUnderline = useDashboardSelector(selectDisableKpiDashboardHeadlineUnderline);
    var isDrillable = kpiWidget.drills.length > 0;
    var isSaving = useDashboardSelector(selectIsDashboardSaving);
    var isEditable = !isSaving;
    var dispatch = useDashboardDispatch();
    var coordinates = useDashboardSelector(selectWidgetCoordinatesByRef(widgetRef(kpiWidget)));
    var onWidgetDelete = useCallback(function () {
        dispatch(uiActions.openKpiDeleteDialog(coordinates));
    }, [dispatch, coordinates]);
    var measures = useDashboardSelector(selectAllCatalogMeasuresMap);
    var currentMeasure = measures.get(kpiWidget.kpi.metric);
    var onWidgetTitleChanged = useCallback(function (newTitle) {
        if (newTitle) {
            dispatch(changeKpiWidgetHeader(kpiWidget.ref, { title: newTitle }));
        }
        else if (currentMeasure) {
            dispatch(changeKpiWidgetHeader(kpiWidget.ref, { title: currentMeasure.measure.title }));
        }
    }, [currentMeasure, dispatch, kpiWidget.ref]);
    var _e = useKpiExecutionDataView({
        backend: backend,
        workspace: workspace,
        primaryMeasure: primaryMeasure,
        secondaryMeasure: secondaryMeasure,
        effectiveFilters: effectiveFilters,
        shouldLoad: kpiDataStatus === "success",
    }), error = _e.error, result = _e.result, status = _e.status;
    var isLoading = isChangingMeasure ||
        status === "loading" ||
        status === "pending" ||
        kpiDataStatus === "loading" ||
        kpiDataStatus === "pending";
    var executionsHandler = useWidgetExecutionsHandler(widgetRef(kpiWidget));
    var _f = useWidgetSelection(widgetRef(kpiWidget)), isSelectable = _f.isSelectable, isSelected = _f.isSelected, onSelected = _f.onSelected, hasConfigPanelOpen = _f.hasConfigPanelOpen;
    var renderBeforeContent = useMemo(function () {
        var hasConfigComponent = !!KpiConfigurationComponent;
        var shouldHaveConfigRendered = isSelected && hasConfigPanelOpen;
        if (!hasConfigComponent || !shouldHaveConfigRendered) {
            return undefined;
        }
        return function KpiConfiguration() {
            return (React.createElement(ConfigurationBubble, null,
                React.createElement(KpiConfigurationComponent, { widget: kpiWidget })));
        };
    }, [KpiConfigurationComponent, hasConfigPanelOpen, isSelected, kpiWidget]);
    useEffect(function () {
        if (error) {
            onError === null || onError === void 0 ? void 0 : onError(error);
            executionsHandler.onError(error);
        }
    }, [error, executionsHandler, onError]);
    return (React.createElement(DashboardItemKpi, { visualizationClassName: cx("s-dashboard-kpi-component", "widget-loaded", "visualization", {
            "kpi-with-pop": kpiWidget.kpi.comparisonType !== "none",
            "content-loading": isLoading,
            "content-loaded": !isLoading,
            "is-editable": isEditable,
        }), contentClassName: cx({ "is-editable": isEditable }), renderBeforeContent: renderBeforeContent, renderAfterContent: function () {
            if (isSelected) {
                return (React.createElement("div", { className: "dash-item-action dash-item-action-delete gd-icon-trash", onClick: onWidgetDelete }));
            }
            return null;
        }, renderHeadline: function (clientHeight) { return (React.createElement(EditableKpiHeadline, { title: titleToShow, clientHeight: clientHeight, onTitleChange: onWidgetTitleChanged })); }, isSelectable: isSelectable, isSelected: isSelected, onSelected: onSelected }, function () {
        var _a;
        if (kpiDataStatus === "loading" || kpiDataStatus === "pending") {
            return React.createElement(LoadingComponent, null);
        }
        if (kpiDataStatus === "error") {
            return React.createElement(ErrorComponent, { message: kpiDataError.message });
        }
        return (React.createElement(KpiRenderer, { kpi: kpiWidget, kpiResult: getKpiResult(result, primaryMeasure, secondaryMeasure, separators), filters: (_a = kpiDataResult === null || kpiDataResult === void 0 ? void 0 : kpiDataResult.effectiveFilters) !== null && _a !== void 0 ? _a : [], separators: separators, enableCompactSize: enableCompactSize, error: error, errorHelp: intl.formatMessage({ id: "kpi.error.view" }), isLoading: isLoading, 
            // need to pass something so that the underline is shown...
            onDrill: noop, isDrillable: isDrillable, disableDrillUnderline: disableDrillUnderline }));
    }));
};
//# sourceMappingURL=EditModeDashboardKpi.js.map