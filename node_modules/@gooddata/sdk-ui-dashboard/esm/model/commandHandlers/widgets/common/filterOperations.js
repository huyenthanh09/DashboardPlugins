import { __generator, __read, __spread } from "tslib";
// (C) 2021-2022 GoodData Corporation
import { areObjRefsEqual, isDashboardAttributeFilterReference, isInsightWidget, isKpiWidget, } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
import { call, select } from "redux-saga/effects";
import { selectFilterContextAttributeFilters } from "../../../store/filterContext/filterContextSelectors";
import { selectAllCatalogDateDatasetsMap } from "../../../store/catalog/catalogSelectors";
import { query } from "../../../store/_infra/queryCall";
import { insightSelectDateDataset, queryDateDatasetsForInsight, queryDateDatasetsForMeasure, } from "../../../queries";
function toAttributeDisplayFormRefs(references) {
    return references.filter(isDashboardAttributeFilterReference).map(function (reference) { return reference.displayForm; });
}
function getIgnoredAttributeFilters(filters, ignored) {
    var ignoredRefs = toAttributeDisplayFormRefs(ignored);
    return filters.filter(function (filter) {
        return ignoredRefs.some(function (ref) { return areObjRefsEqual(filter.attributeFilter.displayForm, ref); });
    });
}
function replaceFilterSettings(ctx, validators, cmd, widget, op) {
    var dateDataSet, ignoredFilters;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!op.dateDatasetForFiltering) return [3 /*break*/, 2];
                return [4 /*yield*/, call(validators.dateDatasetValidator, ctx, cmd, widget, op.dateDatasetForFiltering)];
            case 1:
                dateDataSet = _a.sent();
                _a.label = 2;
            case 2:
                ignoredFilters = undefined;
                if (!op.ignoreAttributeFilters) return [3 /*break*/, 4];
                return [4 /*yield*/, call(validators.attributeFilterValidator, ctx, cmd, widget, op.ignoreAttributeFilters)];
            case 3:
                ignoredFilters = _a.sent();
                _a.label = 4;
            case 4: return [2 /*return*/, {
                    dateDataSet: dateDataSet,
                    ignoredFilters: ignoredFilters,
                }];
        }
    });
}
function changeDateFilterIgnore(widget, dateDataSet) {
    var attributeFilters, ignoredFilters;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectFilterContextAttributeFilters)];
            case 1:
                attributeFilters = _a.sent();
                ignoredFilters = getIgnoredAttributeFilters(attributeFilters, widget.ignoreDashboardFilters);
                return [2 /*return*/, {
                        dateDataSet: dateDataSet,
                        ignoredFilters: ignoredFilters,
                    }];
        }
    });
}
function disableDateFilter(_ctx, _validators, _cmd, widget) {
    var result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(changeDateFilterIgnore, widget, undefined)];
            case 1:
                result = _a.sent();
                return [2 /*return*/, result];
        }
    });
}
function enableDateFilter(ctx, validators, cmd, widget, op) {
    var dateDatasetToUse, queryResult, queryResult, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(op.dateDataset === "default")) return [3 /*break*/, 6];
                if (!isInsightWidget(widget)) return [3 /*break*/, 2];
                return [4 /*yield*/, call(query, queryDateDatasetsForInsight(widget.insight))];
            case 1:
                queryResult = _a.sent();
                dateDatasetToUse = insightSelectDateDataset(queryResult);
                return [3 /*break*/, 5];
            case 2:
                if (!isKpiWidget(widget)) return [3 /*break*/, 4];
                return [4 /*yield*/, call(query, queryDateDatasetsForMeasure(widget.kpi.metric))];
            case 3:
                queryResult = _a.sent();
                dateDatasetToUse = queryResult.dateDatasetsOrdered[0];
                return [3 /*break*/, 5];
            case 4:
                invariant(false, "Cannot use default date dataset for custom widgets");
                _a.label = 5;
            case 5: return [3 /*break*/, 8];
            case 6: return [4 /*yield*/, call(validators.dateDatasetValidator, ctx, cmd, widget, op.dateDataset)];
            case 7:
                dateDatasetToUse = _a.sent();
                _a.label = 8;
            case 8: return [4 /*yield*/, call(changeDateFilterIgnore, widget, dateDatasetToUse)];
            case 9:
                result = _a.sent();
                return [2 /*return*/, result];
        }
    });
}
function changeAttributeIgnores(widget, newlyIgnoredFilters) {
    var dateDataSetMap, dateDataSet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectAllCatalogDateDatasetsMap)];
            case 1:
                dateDataSetMap = _a.sent();
                dateDataSet = widget.dateDataSet ? dateDataSetMap.get(widget.dateDataSet) : undefined;
                return [2 /*return*/, {
                        dateDataSet: dateDataSet,
                        ignoredFilters: newlyIgnoredFilters,
                    }];
        }
    });
}
function replaceAttributeIgnores(ctx, validators, cmd, widget, op) {
    var ignoredFilters, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(validators.attributeFilterValidator, ctx, cmd, widget, op.displayFormRefs)];
            case 1:
                ignoredFilters = _a.sent();
                return [4 /*yield*/, call(changeAttributeIgnores, widget, ignoredFilters)];
            case 2:
                result = _a.sent();
                return [2 /*return*/, result];
        }
    });
}
function ignoreAttributeFilter(ctx, validators, cmd, widget, op) {
    var ignoredFilters, attributeFilters, alreadyIgnored, addToIgnore, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(validators.attributeFilterValidator, ctx, cmd, widget, op.displayFormRefs)];
            case 1:
                ignoredFilters = _a.sent();
                return [4 /*yield*/, select(selectFilterContextAttributeFilters)];
            case 2:
                attributeFilters = _a.sent();
                alreadyIgnored = getIgnoredAttributeFilters(attributeFilters, widget.ignoreDashboardFilters);
                addToIgnore = (ignoredFilters !== null && ignoredFilters !== void 0 ? ignoredFilters : []).filter(function (candidate) {
                    return !alreadyIgnored.some(function (ignoredFilter) {
                        return areObjRefsEqual(ignoredFilter.attributeFilter.displayForm, candidate.attributeFilter.displayForm);
                    });
                });
                return [4 /*yield*/, call(changeAttributeIgnores, widget, __spread(alreadyIgnored, addToIgnore))];
            case 3:
                result = _a.sent();
                return [2 /*return*/, result];
        }
    });
}
function unignoreAttributeFilter(ctx, validators, cmd, widget, op) {
    var unignoredFilters, attributeFilters, alreadyIgnored, reducedIgnores, result;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(validators.attributeFilterValidator, ctx, cmd, widget, op.displayFormRefs)];
            case 1:
                unignoredFilters = _a.sent();
                return [4 /*yield*/, select(selectFilterContextAttributeFilters)];
            case 2:
                attributeFilters = _a.sent();
                alreadyIgnored = getIgnoredAttributeFilters(attributeFilters, widget.ignoreDashboardFilters);
                reducedIgnores = alreadyIgnored.filter(function (candidate) {
                    return !(unignoredFilters !== null && unignoredFilters !== void 0 ? unignoredFilters : []).some(function (toRemove) {
                        return areObjRefsEqual(candidate.attributeFilter.displayForm, toRemove.attributeFilter.displayForm);
                    });
                });
                return [4 /*yield*/, call(changeAttributeIgnores, widget, reducedIgnores)];
            case 3:
                result = _a.sent();
                return [2 /*return*/, result];
        }
    });
}
/**
 * This is one of the more complex event handlers. Here is a little introduction to make studying easier. You
 * really should read this first because you start messing around here villy-nilly. It can simplify things hopefully.
 *
 * In order to provide rich/convenient API for fiddling with widget filters, the widget filter setting commands
 * allow caller to use different types of operations such as:
 *
 * -  replace filter settings completely
 * -  enable/disable date filter (by setting or unsetting date dataset)
 * -  replace list of attribute filters to ignore
 * -  add/remove one or more items from a list of attribute filters to ignore
 *
 * To keep things sane, the handler opts out for convenient - yet perhaps not optimal approach to implement these
 * operations:
 *
 * 1.  The operation to replace filter settings completely can handle validation and resolution of date dataset
 *     to filter by and attribute filters to ignore. In a way, this is the ultimate operation that can achieve
 *     everything.
 *
 * 2.  All the other operations are just thin wrappers on top of the replace filter settings. The sub-operation always
 *     prepare a 'quasi replace' or 'intermediate replace', call the the replace settings operation and
 *     then either send the results off or tweak them.
 *
 *     The latter is the case for the ignore/unignore one or more attribute filter operations. These cannot be
 *     mapped 1-1 to just the replace. However, the replace operation is still used to do intermediate work/validations.
 *
 *     The result of the intermediate operation is then tweaked. The funniest example is the unignore operation:
 *
 *     -  the intermediate operation is set with the existing date data set setting that is on the widget - this is
 *        because it should be untouched yet we need to perform resolution to catalog date dataset for the
 *        purpose of having nice, rich eventing in the end
 *
 *     -  the intermediate operation is set with attribute filters that should be removed from ignore list. that is
 *        because code needs to verify the input - whether the display form is valid and used in some attribute filter
 *
 *     -  the replace operation does the validations.. it essentially resolves date data set ref to a nice catalog
 *        date dataset info & resolves display form of the filter to remove to an attribute filter to remove
 *
 *     -  the unignore op then fiddles with with existing ignore list and removes the attribute filter that was
 *        validated and resolved by the intermediate replace operation
 */
export function processFilterOp(ctx, validators, cmd, widget) {
    var operation, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                operation = cmd.payload.operation;
                _a = operation.type;
                switch (_a) {
                    case "replace": return [3 /*break*/, 1];
                    case "disableDateFilter": return [3 /*break*/, 3];
                    case "enableDateFilter": return [3 /*break*/, 5];
                    case "replaceAttributeIgnores": return [3 /*break*/, 7];
                    case "ignoreAttributeFilter": return [3 /*break*/, 9];
                    case "unignoreAttributeFilter": return [3 /*break*/, 11];
                }
                return [3 /*break*/, 13];
            case 1: return [4 /*yield*/, call(replaceFilterSettings, ctx, validators, cmd, widget, operation)];
            case 2: return [2 /*return*/, _b.sent()];
            case 3: return [4 /*yield*/, call(disableDateFilter, ctx, validators, cmd, widget)];
            case 4: return [2 /*return*/, _b.sent()];
            case 5: return [4 /*yield*/, call(enableDateFilter, ctx, validators, cmd, widget, operation)];
            case 6: return [2 /*return*/, _b.sent()];
            case 7: return [4 /*yield*/, call(replaceAttributeIgnores, ctx, validators, cmd, widget, operation)];
            case 8: return [2 /*return*/, _b.sent()];
            case 9: return [4 /*yield*/, call(ignoreAttributeFilter, ctx, validators, cmd, widget, operation)];
            case 10: return [2 /*return*/, _b.sent()];
            case 11: return [4 /*yield*/, call(unignoreAttributeFilter, ctx, validators, cmd, widget, operation)];
            case 12: return [2 /*return*/, _b.sent()];
            case 13: return [2 /*return*/];
        }
    });
}
//# sourceMappingURL=filterOperations.js.map