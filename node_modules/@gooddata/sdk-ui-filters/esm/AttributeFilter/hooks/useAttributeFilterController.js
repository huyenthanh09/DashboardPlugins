import { __assign } from "tslib";
// (C) 2022 GoodData Corporation
import { useCallback, useEffect } from "react";
import isEqual from "lodash/isEqual";
import debounce from "lodash/debounce";
import { filterAttributeElements, isAttributeElementsByRef, isAttributeElementsByValue, isNegativeAttributeFilter, } from "@gooddata/sdk-model";
import { useBackendStrict, useWorkspaceStrict } from "@gooddata/sdk-ui";
import { useResolveFilterInput } from "./useResolveFilterInput";
import { useResolveParentFiltersInput } from "./useResolveParentFiltersInput";
import { useAttributeFilterHandler } from "./useAttributeFilterHandler";
import { useAttributeFilterControllerData } from "./useAttributeFilterControllerData";
import { PARENT_FILTERS_CORRELATION, RESET_CORRELATION, SEARCH_CORRELATION } from "./constants";
/**
 * UseAttributeFilterController hook is responsible for initialization of AttributeFilterHandler {@link IMultiSelectAttributeFilterHandler} Core API for Attribute Filter components
 *
 * @remarks
 * You can access AttributeFilter state and callbacks ({@link AttributeFilterController})
 *
 * This is the best option if you need to implement fully custom UI for the attribute filter. This option requires a bit more coding, but you have a full control over the UI.
 * It has identical convenient API as AttributeFilter component - same input props and same output props that are available in the internal context of the AttributeFilter component.
 * It works out of the box with other UI.SDK things - {@link @gooddata/sdk-ui#BackendProvider}, {@link @gooddata/sdk-ui#WorkspaceProvider} and visualization definition placeholders.
 *
 * @public
 */
export var useAttributeFilterController = function (props) {
    var backendInput = props.backend, workspaceInput = props.workspace, filterInput = props.filter, identifier = props.identifier, connectToPlaceholder = props.connectToPlaceholder, parentFilters = props.parentFilters, parentFilterOverAttribute = props.parentFilterOverAttribute, onApply = props.onApply, onError = props.onError, hiddenElements = props.hiddenElements, staticElements = props.staticElements, elementsOptions = props.elementsOptions;
    var backend = useBackendStrict(backendInput, "AttributeFilter");
    var workspace = useWorkspaceStrict(workspaceInput, "AttributeFilter");
    var _a = useResolveFilterInput(filterInput, connectToPlaceholder, identifier), filter = _a.filter, setConnectedPlaceholderValue = _a.setConnectedPlaceholderValue;
    var limitingAttributeFilters = useResolveParentFiltersInput(parentFilters, parentFilterOverAttribute);
    var handler = useAttributeFilterHandler({
        backend: backend,
        filter: filter,
        workspace: workspace,
        hiddenElements: hiddenElements,
        staticElements: staticElements,
    });
    var attributeFilterControllerData = useAttributeFilterControllerData(handler);
    useOnError(handler, { onError: onError });
    useInitOrReload(handler, {
        filter: filter,
        limitingAttributeFilters: limitingAttributeFilters,
        limit: elementsOptions === null || elementsOptions === void 0 ? void 0 : elementsOptions.limit,
        onApply: onApply,
        setConnectedPlaceholderValue: setConnectedPlaceholderValue,
    });
    var callbacks = useCallbacks(handler, { onApply: onApply, setConnectedPlaceholderValue: setConnectedPlaceholderValue });
    return __assign(__assign({}, attributeFilterControllerData), callbacks);
};
//
function useOnError(handler, props) {
    var onError = props.onError;
    useEffect(function () {
        function handleError(payload) {
            onError === null || onError === void 0 ? void 0 : onError(payload.error);
        }
        var callbackUnsubscribeFunctions = [
            handler.onInitError(handleError),
            handler.onLoadAttributeError(handleError),
            handler.onLoadInitialElementsPageError(handleError),
            handler.onLoadNextElementsPageError(handleError),
            handler.onLoadCustomElementsError(handleError),
        ];
        return function () {
            callbackUnsubscribeFunctions.forEach(function (unsubscribe) {
                unsubscribe();
            });
        };
    }, [handler, onError]);
}
//
function useInitOrReload(handler, props) {
    var filter = props.filter, limitingAttributeFilters = props.limitingAttributeFilters, limit = props.limit, setConnectedPlaceholderValue = props.setConnectedPlaceholderValue, onApply = props.onApply;
    useEffect(function () {
        if (limitingAttributeFilters.length > 0) {
            handler.setLimitingAttributeFilters(limitingAttributeFilters);
        }
        if (limit) {
            handler.setLimit(limit);
        }
        handler.init();
        // Change of the parent filters is resolved in the useEffect bellow,
        // it does not need full reinit.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [handler]);
    useEffect(function () {
        var _a;
        if (!isEqual(limitingAttributeFilters, handler.getLimitingAttributeFilters())) {
            handler.changeSelection({ keys: [], isInverted: true });
            handler.setLimitingAttributeFilters(limitingAttributeFilters);
            // the next lines are to apply selection to the state of the parent component to make the
            // new attribute filter state persistent
            handler.commitSelection();
            var nextFilter = handler.getFilter();
            var isInverted = (_a = handler.getCommittedSelection()) === null || _a === void 0 ? void 0 : _a.isInverted;
            setConnectedPlaceholderValue(nextFilter);
            onApply === null || onApply === void 0 ? void 0 : onApply(nextFilter, isInverted);
            if (handler.getInitStatus() !== "success") {
                handler.init(PARENT_FILTERS_CORRELATION);
            }
            else {
                handler.loadInitialElementsPage(PARENT_FILTERS_CORRELATION);
            }
        }
        else if (!isEqual(filter, handler.getFilter())) {
            var elements = filterAttributeElements(filter);
            var keys = isAttributeElementsByValue(elements) ? elements.values : elements.uris;
            var isInverted = isNegativeAttributeFilter(filter);
            handler.changeSelection({ keys: keys, isInverted: isInverted });
            handler.commitSelection();
            handler.init();
        }
    }, [filter, limitingAttributeFilters, handler, onApply, setConnectedPlaceholderValue]);
}
//
function useCallbacks(handler, props) {
    var onApplyInput = props.onApply, setConnectedPlaceholderValue = props.setConnectedPlaceholderValue;
    var onSelect = useCallback(function (selectedItems, isInverted) {
        var attributeFilter = handler.getFilter();
        var isElementsByRef = isAttributeElementsByRef(filterAttributeElements(attributeFilter));
        var keys = selectedItems.map(function (item) { return (isElementsByRef ? item.uri : item.title); });
        handler.changeSelection({ keys: keys, isInverted: isInverted });
    }, [handler]);
    // Rule is not working with debounce
    // eslint-disable-next-line react-hooks/exhaustive-deps
    var onSearch = useCallback(debounce(function (search) {
        if (handler.getSearch() !== search) {
            handler.setSearch(search);
        }
        handler.loadInitialElementsPage(SEARCH_CORRELATION);
    }, 200), [handler]);
    var onLoadNextElementsPage = useCallback(function () {
        handler.loadNextElementsPage();
    }, [handler]);
    var onReset = useCallback(function () {
        handler.revertSelection();
        if (handler.getSearch().length > 0) {
            handler.setSearch("");
            handler.loadInitialElementsPage(RESET_CORRELATION);
        }
    }, [handler]);
    var onApply = useCallback(function () {
        var _a;
        handler.commitSelection();
        var nextFilter = handler.getFilter();
        var isInverted = (_a = handler.getCommittedSelection()) === null || _a === void 0 ? void 0 : _a.isInverted;
        setConnectedPlaceholderValue(nextFilter);
        onApplyInput === null || onApplyInput === void 0 ? void 0 : onApplyInput(nextFilter, isInverted);
    }, [onApplyInput, setConnectedPlaceholderValue, handler]);
    return {
        onApply: onApply,
        onLoadNextElementsPage: onLoadNextElementsPage,
        onSearch: onSearch,
        onSelect: onSelect,
        onReset: onReset,
    };
}
//# sourceMappingURL=useAttributeFilterController.js.map